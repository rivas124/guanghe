import { AxiosError } from 'axios'
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import { api, url } from '../../configs'

import { IKeyword, IReport, IKeywordData, Report, ICommunity } from 'src/types'
import { RootState } from '../index'
export interface ReportsState {
  keyword: IKeyword[]
  reports: Report[]
  keywords: IKeywordData[]
  community: ICommunity[]
}

const initialState: ReportsState = {
  keyword: [],
  reports: [],
  keywords: [],
  community: [],
}

export const getKeywordAction = createAsyncThunk(
  'reports/getKeyword',
  async ({}, thunk) => {
    try {
      return await api.get(url.getKeyword)
    } catch (e) {
      return thunk.rejectWithValue((e as AxiosError).message)
    }
  }
)

export const saveReportAction = createAsyncThunk(
  'reports/saveReport',
  async (payload: Report, thunk) => {
    try {
      return await api.post(url.saveReport, payload)
    } catch (e) {
      return thunk.rejectWithValue((e as AxiosError).message)
    }
  }
)

export const updateReportAction = createAsyncThunk(
  'reports/updateReport',
  async (payload: Report, thunk) => {
    try {
      return await api.put(`${url.updateReport}/${payload.id}`, payload)
    } catch (e) {
      return thunk.rejectWithValue((e as AxiosError).message)
    }
  }
)

export const createReportAction = createAsyncThunk(
  'reports/createReport',
  async (payload: Report, thunk) => {
    try {
      return await api.post(url.createReport, payload)
    } catch (e) {
      return thunk.rejectWithValue((e as AxiosError).message)
    }
  }
)

export const deleteReportAction = createAsyncThunk(
  'reports/deleteReport',
  async (query: { reportId: string }, thunk) => {
    try {
      return await api.delete(url.deleteReport + '/' + query.reportId)
    } catch (e) {
      return thunk.rejectWithValue((e as AxiosError).message)
    }
  }
)

export const generateReportAction = createAsyncThunk(
  'reports/generateReport',
  async (payload: IReport, thunk) => {
    try {
      return await api.post(url.generateReport, payload)
    } catch (e) {
      return thunk.rejectWithValue((e as AxiosError).message)
    }
  }
)

export const getReportAction = createAsyncThunk(
  'reports/getReport',
  async (query: { reportId: string }, thunk) => {
    try {
      return await api.get(url.getReport, query)
    } catch (e) {
      return thunk.rejectWithValue((e as AxiosError).message)
    }
  }
)

export const getCommunityAction = createAsyncThunk(
  'reports/getCommunity',
  async (query: { id: string }, thunk) => {
    try {
      return await api.get(`${url.getCommunity}/${query.id}`, {})
    } catch (e) {
      return thunk.rejectWithValue((e as AxiosError).message)
    }
  }
)

export const getReportsAction = createAsyncThunk(
  'reports/getReports',
  async ({}, thunk) => {
    try {
      return await api.get(url.getReports)
    } catch (e) {
      return thunk.rejectWithValue((e as AxiosError).message)
    }
  }
)

export const reportsSlice = createSlice({
  name: 'reports',
  initialState,
  reducers: {
    deleteReport: (state, action) => {
      const newReports = state.reports.filter(
        (report) => report.id !== action.payload.id
      )

      state.reports = [...newReports]
    },
    saveAllKeywords: (state, action) => {
      state.keywords = action.payload
    },
    saveNewKeyword: (state, action) => {
      const { id, keyword, transformations } = action.payload
      const newKeyword = {
        id,
        keyword: keyword,
        transformations: transformations,
      }

      state.keywords.push(newKeyword)
    },
    updateKeyword: (state, action) => {
      const { id, keyword, transformations } = action.payload
      const updatedKeyword = {
        id,
        keyword: keyword,
        transformations: transformations,
      }

      const updatedKeywordIndex = state.keywords.findIndex(
        (keyword) => keyword.id === id
      )
      const newKeywords = [...state.keywords]
      newKeywords[updatedKeywordIndex] = updatedKeyword

      state.keywords = [...newKeywords]
    },
    deleteKeyword: (state, action) => {
      const newKeywords = state.keywords.filter(
        (keyword) => keyword.id !== action.payload.id
      )

      state.keywords = [...newKeywords]
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(getKeywordAction.fulfilled, (state, action) => {
      state.keyword = action.payload as IKeyword[]
    })
    builder.addCase(getCommunityAction.fulfilled, (state, action) => {
      state.community = action.payload as ICommunity[]
    })
    builder.addCase(saveReportAction.fulfilled, (state, action) => {})
    builder.addCase(getReportsAction.fulfilled, (state, action) => {
      state.reports = action.payload as Report[]
    })
    builder.addCase(updateReportAction.fulfilled, (state, action) => {})
    builder.addCase(deleteReportAction.fulfilled, (state, action) => {})
  },
})

// Actions
export const {
  deleteReport,
  saveNewKeyword,
  updateKeyword,
  deleteKeyword,
  saveAllKeywords,
} = reportsSlice.actions

export const selectReports = (state: RootState) => state.reports.reports
export const selectKeywords = (state: RootState) => state.reports.keywords
export const selectKeyword = (state: RootState) => state.reports.keyword
export const selectCommunity = (state: RootState) => state.reports.community

export default reportsSlice.reducer
